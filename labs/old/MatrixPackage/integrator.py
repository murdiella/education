from sys import float_info
import model as mo
from math import sqrt


# класс интегратора
class TIntegrator(mo.Model):
    _eps = float  # максимальная погрешность на шаге

    def __init__(self):
        super().__init__()
        self._eps = 1e-8

    def set_precision(self, f_eps):
        self._eps = f_eps

    def get_precision(self, f_eps):
        return self._eps

    # метод, реализующий процедуру численного интегрирования и возвращающий глобальную погрешность вычислений
    def run(self, model):
        return 0


class TDormandPrinceIntegrator(TIntegrator):
    # коэффициенты a, b, c (__a -- private)
    __a = list
    __b1 = list
    __b2 = list
    __c = list
    # коэффициенты k[i]
    __k = list
    # машинный нуль
    __u = float

    def __init__(self):
        super().__init__()
        self.__c = [0, 1/5, 3/10, 4/5, 8/9, 1, 1]
        self.__a = [
            [0],
            [1/5],
            [3/40, 9/40],
            [44/45, -56/15, 32/9],
            [19372/6561, -25360/2187, 64448/6561, -212/729],
            [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656],
            [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84]
        ]
        self.__b1 = [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0]
        self.__b2 = [5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40]

        # машинный нуль
        self.__u = float_info.epsilon

    def run(self, model):
        # время интегрирования (увеличивается на величину шага интегрирования)
        t = model.get_t0()
        # время для выдачи (увеличивается на величину плотности)
        t_out = t
        # конечное время
        t1 = model.get_t1()
        # шаг интегрирования
        h = float
        # шаг после коррекции
        h_new = model.get_samp_inc()
        # ошибка на шаге интегрирования
        e = 0

        # вектор состояния на начало шага
        X = model.get_init_cond()
        # вектор состояния на конец шага
        X1 = X  # для совпадения размерности, потом пересчитается
        # вектор состояния на конец шага для коррекции величины шага (решение 5-го порядка)
        X2 = X  # для совпадения размерности, потом пересчитается
        # вектор выдачи результата
        X_out = X  # для совпадения размерности, потом пересчитается
        # буфер вычисления коэффициентов K
        Y = X.get_magnitude()

        # подготовка хранилища результатов в модели для повышения эффективности выделения памяти
        model.prep_result()

        # инициализируем размерности коэффициентов K[j]
        K = []
        for i in range(7, 0, -1):
            K.append([0] * X.get_length())

        # счетчик количества сделанных шагов
        n = 0

        # главный цикл
        while t < t1:
            # устанавливаем шаг на итерацию
            h = h_new

            # вычисляем коэффициенты K
            K[0] = model.get_right(X, t)
            K[1] = model.get_right(X + h * self.__a[1][0]*K[0], t + h/10)
            K[2] = model.get_right(X + h * (self.__a[2][0] * K[0] + self.__a[2][1] * K[1]), t + 3 * h / 10)
            K[3] = model.get_right(X + h * (self.__a[3][0] * K[0] + self.__a[3][1] * K[1] + self.__a[3][2] * K[2]), t + 4 * h / 5)
            K[4] = model.get_right(X + h * (self.__a[4][0] * K[0] + self.__a[4][1] * K[1] + self.__a[4][2] * K[2] + self.__a[4][3] * K[3]), t + 8 * h / 9)
            K[5] = model.get_right(X + h * (self.__a[5][0] * K[0] + self.__a[5][1] * K[1] + self.__a[5][2] * K[2] + self.__a[5][3] * K[3] + self.__a[5][4] * K[4]), t + h)
            K[6] = model.get_right(X + h * (self.__a[6][0] * K[0] + self.__a[6][1] * K[1] + self.__a[6][2] * K[2] + self.__a[6][3] * K[3] + self.__a[6][4] * K[4] + self.__a[6][5] * K[5]), t + h)

            # вычисляем решения 4-го и 5-го порядков
            X1 = X + h * (self.__b1[0] * K[0] + self.__b1[1] * K[1] + self.__b1[2] * K[2] + self.__b1[3] * K[3] + self.__b1[4] * K[4] + self.__b1[5] * K[5] + self.__b1[6] * K[6])
            X2 = X + h * (self.__b2[0] * K[0] + self.__b2[1] * K[1] + self.__b2[2] * K[2] + self.__b2[3] * K[3] + self.__b2[4] * K[4] + self.__b2[5] * K[5] + self.__b2[6] * K[6])

            # вычисление локальной ошибки
            e = 0
            for i in range(len(K)):
                e += pow(((h * (X1[i] - X2[i])) / (max([pow(10, -5), abs(X[i]), abs(X1[i]), (2 * self.__u) / self._eps]))), 2)
            e = sqrt(e / len(X))

            # вычисление нового значения шага
            h_new = h / (max(0.1, min(5, pow(e / self._eps, 0.2)/0.9)))

            # если локальнаяя ошибка превышает установленную величину, делаем шаг щаново
            if e > self._eps:
                continue

            # формирование результатов при помощи механизма плотной выдачи
            while (t_out < t + h) and (t_out <= t1):
                theta = (t_out - t) / h
                b = [0] * 6
                # рассчитываем коэффициенты плотной выдачи
                b[0] = theta * (1 + theta*(-1337 / 480 + theta * (1039/360 + theta * (-1163 / 1152))))
                b[1] = 0
                b[2] = 100 * theta * theta * (1054 / 9275 + theta * (-4682 / 27825 + theta * (379 / 5565))) / 3
                b[3] = -5 * theta * theta * (27 / 40 + theta * (-9 / 5 + theta * (83 / 96))) / 2
                b[4] = 18225 * theta * theta * (-3 / 250 + theta * (22 / 375 + theta * (-37 / 600))) / 848
                b[5] = -22 * theta * theta * (-3 / 10 + theta * (29 / 30 + theta * (-17 / 24))) / 7

                # получаем результат для выдачи
                X_out = X + h * (b[0] * K[0] + b[1] * K[1] + b[2] * K[2] + b[3] * K[3] + b[4] * K[4] + b[5] * K[5])

                # передача результата в модель
                model.add_result(X_out, t_out)
                # наращиваем время выдачи
                t_out += model.get_samp_inc()

            # обновляем Х решением 5-го порядка и наращиваем время на величину шага
            X = X2
            t += h

            # считаем кол-во итераций для вычисления погрешности
            n += 1
